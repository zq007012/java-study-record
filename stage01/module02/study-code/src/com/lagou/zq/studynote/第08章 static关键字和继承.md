# 第08章 static关键字和继承

[toc]



## 一. `static`关键字==(重点)==

### 1. 基本概念

- 使用static关键字修饰成员变量表示静态的含义, 这种变量被称作静态变量, 此时该成员变量由对象层级提升为类层级, 也就是这个类以及由该类new出来的所有对象只有这一份并且由大家共享, 该静态变量随着类的加载准备就绪, 与是否创建对象无关
- static关键字修饰的成员变量可以使用 **引用.** 的方式访问 , 也可以使用 **类名.** 的方式访问 , 但推荐 **类名.** 的方式. (这样可以在调用时对成员变量和静态变量加以区分, 可读性更好)

### 2. 使用方式

- ==在非静态成员方法中既能访问非静态的成员又能访问静态的成员== ,这是因为静态成员被所有对象共享. [这里的成员是指: 成员变量和成员方法 ]
- ==在静态成员方法中只能访问静态成员不能访问非静态成员==, 这是因为静态方法是随类的加载就到了方法区上 , 而对象是在类加载完后才能在堆内存上开辟空间 , 静态方法的产生在对象的成员产生之前 ,所以静态成员方法只能调用静态成员 .
- ==在以后的开发中只有隶属于类层级并被所有对象共享的内容才可以使用static关键字修饰. (不能滥用static关键字)==
- 不可以出现  同名的和参数列表相同的 静态方法和普通方法, 否则会编译报错

### 3. 构造块和静态代码块(熟悉)

- 构造块 : 在类体中直接使用`{ }`括起来的代码块

  - 每创建一个对象都会先执行一次构造块
  - 构造块的执行是在构造方法之前的

- 静态代码块 : 使用static关键字修饰的构造块

  - ```java
    static{
    	代码块;
    }
    ```

  - 静态代码块随着类的加载执行一次

### 4. 又见main方法

- 语法格式:

  - ``` java
    class Test{
        public static void main(String[] args){
            System.out.println("参数数组中元素的个数是：" + args.length);
    		System.out.println("传递给main方法的实际参数为：");
    		for(int i = 0; i < args.length; i++) {
    			System.out.println("下标为" + i + "的形参变量数值为：" + args[i]);
    		}
        }
    }
    ```

  - `java Test`  就是运行Test.class文件 ,其本质上就是通过Test这个类名来调用main方法. (因为main方法是静态的所以可以通过类名调用到main方法

    - 如果想要在运行java程序时给main方法传递一些参数 , 则可以使用以下方式运行字节码文件

      - ```
        java Test 路飞 索隆 香吉士 乌索普 布鲁克 
        ```

### 5. 单例设计模式

#### a. 单例设计模式的概念

- 在某些特殊场合中, 一个类对外提供且只提供一个对象时 , 这样的类叫做单例类 , 而设计单例类的流程和思想叫做单例设计模式

#### b. 单例设计模式的实现流程

1. 私有化构造方法 (通过使用`private`关键字修饰构造方法来实现)
2. 声明一个本类类型的成员变量, 该成员变量的值是本类类型的对象 , 并且该成员变量要使用`private static`关键字共同修饰 , 并且
3. 提供可以通过类名调用到的get方法(也就是被`public statci`共同修饰的方法)负责将在上一步中声明的成员变量返回出去

#### c. 单例设计模式的实现方式

##### 1. 饿汉式

在单例类被加载时就会将单例对象创建出来

```java
public class Singleton{
    //第二步
    private static Singleton s = new Singleton();
    
    //第一步
    private Singleton(){}
    
    //第三步
    public static Singleton getInstance(){
        return s;
    }
}
```



##### 2. 懒汉式

只有当单例类的向外提供单例对象的方法被调用时 , 才会将单例对象创建出来

```java
public class Singleton{
    //第二步
    private static Singleton s;
    
    //第一步
    private Singleton(){}
    
    //第三步
    public static Singleton getInstance(){
        if (null == s){
           s = new Singleton();
        }
        return s;
    }
}
```

##### 3. 选哪一个

懒汉式在多核心的cpu中易出现同步问题, 导致单例失败 , 所以单例模式优先选择饿汉式

## 二. 继承==(重中之重)==

### 1. 继承的由来

![](%E7%AC%AC08%E7%AB%A0%20static%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E7%BB%A7%E6%89%BF.assets/%E7%BB%A7%E6%89%BF%E7%9A%84%E7%94%B1%E6%9D%A5.png)

### 2. 继承的概念

- 当多个类之间有相同的特征和行为时, 可以将相同的内容提取出来组成一个公共类, 让多个类吸收公共类中已有特征和行为, 而这些类只需要编写自己独有特征和行为的机制

- 在Java语言中使用extends(扩展)关键字来表示继承关系

  - ```java
    //例如:
    public class Workers extends Person{
    	类体;
    }
    ```

  - 其中Person类叫做超类、父类、基类；Worker类叫做派生类、子类、孩子类

- 使用继承提高了代码的复用性，可维护性及扩展性。是多态的前提条件

### 3. 继承的特点

- 子类不能继承父类的构造方法，私有成员可以被继承但会被隐藏, 导致无法被直接直接访问到
  - 私有成员变量可以被继承但不能被直接访问, (可以通过super.set(参数列表)和super.get()来间接直接访问到)
  - 私有成员方法可以被继承但不能被直接访问, 因为被隐藏了 , 所以不能被重写
- 子类可以继承父类的静态成员, 但不论父类的静态成员是否是私有, 都会被隐藏, 所以静态成员不能被重写. 
  - 子类可以声明的跟父类同名的静态成员, 也就只是同名罢了 , 没有任何关系,通过 `子类类名.` 调用到的成员只会是自己的
- 无论使用何种方式构造子类的对象时，都会自动调用父类的无参构造方法，来初始化子类从父类中继承的成员变量，相当于在构造方法的第一行增加代码`super()`的效果
  - 当然如果子类的构造方法自己写了 super(参数列表) ，那么就不会调用父类的无参构造方法了
- 使用继承必须满足逻辑关系：子类 is a 父类， 也就是不能滥用继承
- Java语言中只支持单继承不支持多继承，也就是说一个子类只能有一个父类，但一个父类可以有多个子类

### 4. 方法重写

#### a. 方法重写的概念

从父类中继承下来的方法不满足子类的需求时，就需要在子类中重新写一个和父类一样的方法来覆盖从父类中继承下来的版本，该方式就叫做==方法的重写（override)==

#### b. 方法重写的原则

- 要求方法名相同、参数列表相同以及返回值类型相同，从Java5开始允许返回子类类型
- 要求重写的方法的访问权限不能变小，只能跟父类方法的访问权限相同或变大
- 要求方法不能抛出更大的异常(异常机制)
- 重写后的方法上面写上 注解`@override`来表明这是个重写方法, 如果写了`@override`但实际上这个方法不是重写方法, 那编译阶段就会报错

#### c. 不能重写的几种方法

1. `static`静态方法
2. `private`私有方法
3. 被`final`修饰的方法

这三种方法都是只能被继承但不能被重写

## 三. Java开发的常用工具

- 文本编辑器（TE，Text Editor）
  - 记事本、Notepad++、EditPlus、UltraEdit、Emeditor...
- 集成开发环境（IDE，Integraed Development Environment)
  - Jbuilder、NetBeans、Eclipse、MyEclipse、IDEA...

## 四. 又见构造块与静态代码块==（笔试）==

- 先执行父类的代码块，再执行子类的静态代码块
- 执行父类的构造块，执行父类的构造方法体
- 执行子类的构造块，执行子类的构造方法体

## 五. 访问控制权限

### 1. 常用的访问控制符权限

内部类可以被`private`所修饰

| 修饰符     | 本类                      | 同一个包中的类(子类和其它类)  | 不同包中的子类[这里只是以`super.`访问] | 不同包中的其他类              |
| ---------- | ------------------------- | ----------------------------- | -------------------------------------- | ----------------------------- |
| public     | 可以通过`this.`直接访问到 | 可以通过new出的对象直接访问到 | 可以通过`super.`直接访问到             | 可以通过new出的对象直接访问到 |
| protected  | 可以通过`this.`直接访问到 | 可以通过new出的对象直接访问到 | 可以通过`super.`直接访问到             | 不可以直接访问到              |
| 什么也不写 | 可以通过`this.`直接访问到 | 可以通过new出的对象直接访问到 | 不可以直接访问到                       | 不可以直接访问到              |
| private    | 可以通过`this.`直接访问到 | 不可以直接访问到              | 不可以直接访问到                       | 不可以直接访问到              |

### 2. 注意事项

- public修饰的成员可以在任意位置使用
- priivate修饰的成员只能在本类内部使用
- 通常情况下，成员方法都使用`public`关键字修饰，成员变量都是用`private`关键字修饰

## 六. `package`包

### 1. package语句的由来

- 定义类时需要指定类的名称，但如果仅仅将类名作为类的唯一标识，则不可避免地出现命名冲突的问题。这会给组件复用以及团队间的合作造成很大的麻烦！
- 在Java语言中，用`package`(包)的概念来解决命名冲突的问题

### 2. 包的定义

- 在定义一个类时，除了定义类的名称，一般还要制定一个包名，格式如下：

  - ```java
    package 包名;
    ```

  - ```java
    //或者
    package 包名1.包名2.包名3...包名n;
    ```

- 有助于实现项目管理，解决命名冲突以及权限控制的效果

### 3. 定义包的规范

- 如果各个公司或开发组织的程序员都随心所欲地命名包的话, 仍然不能从根本上解决命名冲突的问题.因此,在指定包名的时候应该按照一定的规范

- `org.apache.commons.lang.StringUtil`

- 其中StringUtil是类名, 而org.apache.common.lang是多层包名, 其含义如下: 

  - | org.apache | 表示公司或组织的信息(是这个公司(或组织)域名的反写,) |
    | ---------- | --------------------------------------------------- |
    | common     | 表示项目的名称信息                                  |
    | lang       | 表示模块的名称信息                                  |

#### 4. 包的导入

- 使用`import`关键字导入包

  - ```java
    import java.util.Scanner;
    //这样可以方便不同包内的类之间的调用,减少了输入类名时的代码量, 可读性更好
    ```
  
- 从Java5.0开始，支持使用`improt static`两个关键字来导入静态成员

  - 导入了Math类中的静态变量PI,现在这个类中可以直接通过变量名来调用PI了

    - ```java
      import static java.lang.Math.PI;
      
      class StaticPackageTest {
          public static void main(String[] args) {
          	System.out.println("圆周率Π = " + PI);
                  
         }
      }
      ```

  - 导入了Math类中的所有静态成员方法, 现在可以直接通过方法名来调用Math中的所有静态方法了

    - ```java
      import static java.lang.Math.*;//
      class StaticPackageTest {
          public static void main(String[] args) {
              System.out.println("16的平方根是:" + sqrt(16 * 1.0));
                  
        	}
      }
      ```

  - 但是非常不建议使用静态导入, 因为这会导致很难判断类中调用的成员变量和成员方法是本类声明的, 还是其它类的静态成员, 可读性较差
## 七. final关键字(重点)

### 1. 基本概念

final本以为“最终的、不可改变的”，可以修饰类、成员方法以及成员变量

### 2. 使用方式

- `final`关键字修饰的类, 体现在该类不能被继承
  - 主要用于防止滥用继承，如：java.lang.String类等
- `final`关键字修饰成员的方法, 体现在该方法可以被继承但不能被重写
  - 主要防止不经意间造成重写 , 如: `java.text.Dateformat`类中的`format`方法等
- `final`关键字修饰的成员变量, 体现在该变量必须初始化且不能改变
  - 主要用于防止不经意间造成改变. 如: `java.lang.Thread`类中的MAX_PRIORITY等

### 3. 常量的概念

- 在以后的开发中很少单独使用final关键字来修饰成员变量, 通常使用public static final关键字共同修饰成员变量来表达常量的含义, 常量的命名规范要求所有字母大写,单词之间用下划线`_`相连
  - `public static final double PI = 3.14`