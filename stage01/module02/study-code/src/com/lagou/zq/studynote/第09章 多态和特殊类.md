# 第09章 多态和特殊类

[toc]

## 一. ==多态(重中之重)==

### 1. 多态的概念

- 多态主要指同一种事务表现出来的多种形态
- 买一杯饮料 :  服务员会问你是买可乐、雪碧、红牛、脉动、...
- 养了一只宠物 ： 你养的是猫、狗、鸟、乌龟、鱼、蜥蜴、...
- 这个人是学生、教师、工人、保安...
- 画个图形 ：是画矩形、圆形、梯形、三角形、...
- ==java语言中的多态指的是 父类类型的引用指向子类类型的对象 的形式==

### 2. 多态的语法格式

- 父类类型 引用变量名 = new 子类类型（）；

  - ```java
    Shape sr = new Rect();
    sr.show();
    ```
### 3. 多态的特点

==下面的父子类都满足一个特点：父类类型的引用指向子类类型的对象==

- 当父类类型的引用指向子类类型的对象时，父类类型的应用可以直接调用父类独有的方法
- 当父类类型的引用指向子类类型的对象时，父类类型的引用不可以直接调用子类独有的方法
- 对于父子类都有的非静态方法来说，编译阶段调用父类版本，运行阶段调用子类重写的版本（动态绑定）
- 对于父子类都有的静态方法来说，编译和运行阶段都是调用父类版本

### 4. 引用数据类型之间的转换

- 引用数据类型之间的转换方式有两种：自动类型转换 和 强制类型转换

- 自动类型转换主要是指小类型引用的类型向大类型转换，也就是子类引用的类型由子类转为父类，这个引用成了父类引用，这叫做向上转型

  - ```java
    Class A{}
    
    Class B extends A{}
    
    Class C extends B{}
    
    C c = new C();
    c instanceof C//true 
    c instanceof B//true --- 自动上转
    c instanceof A//true --- 自动上转
    ```

- 强制类型转化主要指大类型引用的类型向小类型的转换，也就是父类引用的类型由父类转为子类，这个引用成了子类应用，这叫做向下转型

- ==引用的数据类型之间能够相互转换的前提是这些类型之间存在继承或者间接继承的关系，否则编译报错==

#### 引用数据类型之间的强转(向下转型)

- 若强转的目标类型并不是该引用真正指向的子类类型时，那么编译可以通过，运行阶段会发生类型转换异常

- 为了避免上述错误的发生，应该在强转之前进行判断，格式如下：

  - ```java
    if(引用变量 instanceof 数据类型){
        
    }
    //以此来判断引用变量指向的对象是否为后面的数据类型
    ```


### 5. 多态的实际意义

- 多态的实际意义在于屏蔽不同子类的差异性，以此实现通用的编程（父类引用指向子类对象），但同时又能带来不同的效果（子类对方法的重写）

## 二. 抽象类==(重点)==

### 1. 抽象的概念

- 抽象方法主要指没有具体实现的方法体并且使用abstract关键字修饰的方法，也就是没有方法体的方法

- 具体格式如下：

  - ```java
    //访问权限 abstract 返回值类型 方法名(形参列表)；
    public abstract void cry();
    ```

### 2. 抽象类的概念

- 抽象类主要指不能具体实例化因而使用关键字`abstract`修饰的类, 也就是不能创建对象的类

### 3. 抽象类和抽象方法的关系

- 抽象类中可以有成员变量、构造方法、成员方法
- 抽象类中可以没有抽象方法，也可以有抽象方法
- 拥有抽象方法的类必须是抽象类，因此正真意义上的抽象类应该是具有抽象方法并且使用`abstract`关键字修饰的类

### 4. 抽象类的实际意义

- 抽象类的实际意义不在于创建对象而在于被继承
- 当一个类继承抽象类后必须重写抽象方法。佛则该类也变成抽象类，也就是抽象类对子类具有强制性和规范性，因此叫做==模板设计模式==

### 5. 开发经验分享

- 在以后的开发中推荐使用多态的格式，此时父类类型引用直接调用的所有方法一定是父类中拥有的方法，若以后更换子类是，只需要将`new`关键字后面的子类类型修改而其它地方无需改变就可以生效，从而提高了代码的可维护性和可扩展性
- 该方式的缺点就是：父类引用不能直接调用子类独有的方法，若调用则需要对该引用进行强制类型转换转成子类类型

## 三. 接口(重点)

### 1. 接口的基本概念

- 接口就是一种比抽象类还抽象的 存在(因为太过抽象，已经发生了质变，接口不属于类了)，体现在所有方法都为抽象方法且没有构造方法。
- 定义类的关键字是关键字`class`，而定义接口的关键字是`interface`

### 2. 类和接口之间的关系

| 名称                 | 关键字                       | 关系       |
| -------------------- | ---------------------------- | ---------- |
| 类和类之间的关系     | 使用`extends`表达继承关系    | 支持单继承 |
| 类和接口之间的关系   | 使用`implements`表达实现关系 | 支持多实现 |
| 接口和接口之间的关系 | 使用`extends`表达继承关系    | 支持多继承 |

- 类与类只能`extends`，且只能单继承
- 接口与接口之间只能`extends`，可以多继承
- 类与接口之间只能是类`implements`接口，可以多实现
- 类可以继承一个类的同时实现多个接口
- 抽象类可以`implements`接口, 可以在实现接口时不重写接口的方法

### 3. 抽象类和接口的主要区别==(笔试题)==

- 定义抽象类的关键字是`public abstract`，而定义接口的关键字是`interface`

- 继承抽象类的关键字是`extends`，而实现接口的关键字是`implements`

- 类继承抽象类只能单继承，而类实现接口支持多实现

- 接口与接口之间是继承关系, 接口可以多继承接口

- 类可以在继承类的同时，再实现多个接口

- 抽象类一定有构造方法，而接口一定没有构造方法

  - 抽象类毕竟是个类，就算没有自定义构造方法，编译器在编译时也会帮它加一个空构造方法

- 抽象类中可以有成员变量，而接口中只可以有常量

  #### 新特性导致区别的作废2

##### 在Java8之前

  - 抽象类中可以有成员方法，而接口中只可以有抽象方法
  - 抽象类中增加方法时子类可以不用重写, 而接口中增加方法时实现类需要重写

##### Java8开始

接口中允许出现非抽象方法和静态方法, 但非抽象方法需要使用default关键字修饰

- 允许出现非抽象方法的原因是: 当接口要增加一个功能时,所有的实现类都必须实现这个方法,但实际上只有少数几个类甚至是只有一个类需要到这个功能,这样不利于代码的扩展性, 所以Java8新增了允许出现非抽象方法的功能, 使得不需要到这个功能的实现类可以不必实现这个方法, 需要这个功能的类可以不重写这个方法, 把这个方法当作父类的方法来使用,也可以重写这个方法

  - ```java
    public interface InterfaceEg{
        public default void show(){
            方法体;
        }
        //
        public static void staticShow(){
            方法体;
        }
    }
    
    public class InterfaceEgImp implements InterfaceEg{
        public void show(){
            重写后的方法体;
        }
    }
    ```

- 允许出现静态方法

  - 静态方法是通过类名调用的, 在接口中是由接口名调用的, 静态方法可以被继承

##### Java9开始

- 接口中允许出现私有方法, 私有的静态方法和私有的普通方法

  - 允许出现私有方法的原因是: 提高代码的复用性和封装性

    - ```java
      public interface InterfaceEg {
      	//比如show1和show2都需要用到show的代码内容,如果不允许有私有方法出现, 那么show1和show2就都得写上show的代码,使得代码冗余,复用性和封装性都不好
          private void show(){
      		
          }
      
          public default void show1(){
              show();
          }
      
          public default void show2(){
              show();
          }
      }
      ```

    - ```java
      public interface InterfaceEg {
          private static void staticShow(){
      
          }
      
          public static void staticShow1(){
              staticShow();
          }
      
          public static void staticShow2(){
              staticShow();
          }
      ```

- private不可以和default出现在同一方法中

- 在Java9之前, 接口的方法只能使用public一种权限修饰符; 在Java9之后, 接口只能用public和private两种权限修饰符

- private只能用来修饰带方法体的方法, 不可以修饰抽象方法



