public Class Sequeue{
	...
}

成员变量各种初始化的区别
	默认初始化---String cnt;
	显式初始化---String cnt = null; 或者String cnt = "cnt"
	初始化	   ---声明成员变量时没有显式初始化, 第一次以代码给该成员变量赋值
	
new Sequence()

如果Sequence类是第一次被使用, [比如第一次被用来new对象, 第一次被用来调用静态成员]
那么先会执行将Sequence类加载到方法区
1. 先在方法区为Sequence类开辟一个存储空间
2. 在类Sequence的空间内为静态成员变量依次开辟空间, 此时所有的静态成员变量都会被默认初始化, 值都是默认的初始化值
3. 如果有成员变量在声明时, 是显式初始化的声明方式 , 那么现在就开始对成员变量进行显式初始化
4. 执行静态构造代码块
5. Sequence类加载结束

Sequence类加载结束, 在堆区内为对象开辟空间 ; 如果Sequence类不是第一次被使用, 那就说明Sequence类已经被加载好了 ; 会直接开始为对象开辟空间
1. 先在堆区为Sequence对象开辟一个存储空间
2. 在对象Sequence的空间内为成员变量依次开辟空间, 此时所有的成员变量都会被默认初始化, 值都是默认的初始化值
3. 如果有成员变量在声明时, 是显式初始化的声明方式 , 那么现在就开始对成员变量进行显式初始化
4. 执行构造代码块
5. 执行构造方法
成功地new出了Sequence一个对象


SequenceSon extends SequenceFather
new SequenceSon()
如果SequenceSon类是第一次被使用, [比如第一次被用来new对象, 第一次被用来调用静态成员]
那么先会将SequenceSon类加载到方法区
1. 先在方法区为SequenceSon类开辟一个存储空间
2. 在类SequenceSon的空间内为静态成员变量依次开辟空间, 此时所有的静态成员变量都会被默认初始化, 值都是默认的初始化值
		接下来是将SequenceFather类加载到方法区
		a. 先在方法区为SequenceFather类开辟一个存储空间
		b. 在类SequenceFather的空间内为静态成员变量依次开辟空间, 此时所有的静态成员变量都会被默认初始化, 值都是默认的初始化值
		c. 如果有成员变量在声明时, 是显式初始化的声明方式 , 那么现在就开始对成员变量进行显式初始化
		d. 执行静态构造代码块
		e. SequenceSon类加载结束
3. 如果有成员变量在声明时, 是显式初始化的声明方式 , 那么现在就开始对静态成员变量进行显式初始化
4. 执行静态构造代码块
5. SequenceSon类加载结束

SequenceSon类加载结束, 为对象开辟空间 ; 如果SequenceSon类不是第一次被使用, 那就说明SequenceSon类已经被加载好了 ; 会直接开始为对象开辟空间
1. 先在堆区为SequenceSon对象开辟一个存储空间
2. 在对象SequenceSon的空间内为成员变量依次开辟空间, 此时所有的成员变量都会被默认初始化, 值都是默认的初始化值
		接下来会调用SequenceSon的构造方法中的第一行的Super(参数列表), 在SequenceSon的空间内new一个SequenceFather(参数列表)对象
		a. 先在SequenceSon的空间内为SequenceFather对象开辟一个存储空间
		b. 在对象SequenceSequenceFather的空间内为成员变量依次开辟空间, 此时所有的成员变量都会被默认初始化, 值都是默认的初始化值
		c. 如果有成员变量在声明时, 是显式初始化的声明方式 , 那么现在就开始对成员变量进行显式初始化
		d. 执行构造代码块
		e. 执行构造方法
		成功地在SequenceSon对象的空间内new出了一个SequenceFather对象
3. 如果有成员变量在声明时, 是显式初始化的声明方式 , 那么现在就开始对成员变量进行显式初始化
4. 执行构造代码块
5. 执行构造方法 , 第一行的Super(参数列表)会跳过, 从第二行开始执行
成功地new出了Sequence一个对象