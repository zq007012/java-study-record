# 第07章 方法和封装

[toc]

## 一. 构造方法

### 1. 构造方法的基本概念

```java
class 类名 {
    ...//成员变量
    类名(形参列表){
        方法体;
    }
    ...
}
```

- 构造方法名与类名相同
- ==构造方法没有返回值类型, 连void都不许有==
- 构造方法里可以使用`return;`语句, 但不会返回任何值, 只是作为在此结束方法体使用

### 2. 默认构造方法

- 当一个类中没有定义任何构造方法时, 编译器会自动添加一个无参空构造的构造方法, 叫做 默认/缺省构造方法. 如: Person(){}
- ==若类中出现了构造方法, 则编译器不再提供任何形式的构造方法==

### 3. 构造方法的作用

使用new关键字创建对象时会自动调用构造方法实现成员变量初始化工作

## 二. 方法的重载(overload==)重中之重==

### 1. 方法重载的概念

- ==同一个类中==, 若==两个及两个以上的方法的方法名称相同==, ==参数列表不同==, 那么这些方法之间构成重载关系

### 2. 重载的体现形式

- 可以是参数的类型不同
- 可以是参数的个数不同
- 可以是参数的顺序不同
- 是否重载,跟返回值的类型和==形参的变量名==无关, 但建议返回值类型最好相同
- 判断方法能否构成重载的核心: ==调用同名方法时能否通过参数列表加以区分==

### 3. 重载的实际意义

- 方法重载的实际意义在于调用者只需要记住一个方法名就可以调用各种不同的版本, 来实现各种不同的功能
- 如: `java.io.Printstream`类中的println方法

## 三. `this`关键字

### 1. this的基本概念

- 构造方法中出现了this, 那么this代表使用该构造方法构造出来的对象
- 成员方法中出现了this, 那么this代表正在调用该方法的对象

### 2. this的工作原理

==在构造方法中和成员方法中访问成员变量时, 编译器会加上`this.`的前缀, 而`this.`相当于汉语中的"我的"== 

### 3. this的使用方式

- 当局部变量与成员变量同名时, 在方法体中会优先使用局部变量(就近原则), 若希望使用成员变量, 则需要在成员变量的前面加上`this.`的前缀, 这样就能表明该变量是成员变量了(==重中之重==)
- this关键字除了可以通过`this.`的方式调用成员变量和成员方法外, 还可以作为方法的返回值(==重点==)   **[返回的值就是调用这个方法的对象]**

- 在构造方法的第一行可以使用`this(参数列表)`的方式来调用本类中的其他构造方法(了解)

### 4. 注意事项

- 引用类型变量用于存放对象的地址, 可以给引用类型赋值为null , 表示不指向任何对象
- 当某个引用类型变量的值为null时无法对对象实施访问(因为它没有指向任何对象). 此时如果通过引用访问成员变量或调用方法, 会产生 NullPointerException 异常

## 四. 方法递归调用(难点)

```java
//获取正整数n的阶乘
public static int getFactorial(int n){
	/*int result = 1;
	//递推
	for (int i = 1; i <= n ; i++) {
		result *= i;
	}
	return result;*/


	//递归
	if (1 == n) {
		return 1;
	}

	return n * getFactorial(n - 1);
}
```

### 1. 递归的基本概念

- 递归的本质就是在本方法体的内部直接或间接调用本方法的形式

  - ```java
    //求阶乘 --- 递推
    public int getJieCheng1(int n){
    	int result = 1;
    	for (int i = 1; i <= n ; i++) {
    		result *= i;
    	}
    	return result;
    }
    
    //求阶乘 --- 递推
    public int getJieCheng2(int n){
    	//递归
    	if (1 == n) {
    		return 1;
    	}
    
    	return n * getJieCheng2(n - 1);
    }
    
    ```

  - 例如getJieCheng2(5)的执行

    - | return | 5 \* getJieCheng2(4)              |
      | ------ | --------------------------------- |
      | return | 5 \* 4 * getJieCheng2(3)          |
      | return | 5 \* 4 * 3 * getJieCheng2(2)      |
      | return | 5 \* 4 * 3 * 2 \* getJieCheng2(1) |
      | return | 5 \* 4 * 3 * 2 \* 1               |

    - 要得出结果需要调用本方法5次，然后还得运算，不像递推只要调用一次方法就能得到结果，递归虽然代码少，但耗费资源

### 2. 使用递归的注意事项

- 使用递归==必须有递归的规律==以及==退出条件==

- 使用递归必须使得问题简单化而不是复杂化

- 若递归影响到程序的执行性能, 则使用递推取代之

  - ```java
    //递归方法体中,如果是执行了本方法两次或多次才能获得结果,那么就会影响到程序的执行性能,最好考虑其他的方法
    //例如在求费式数列中第n个数的值时使用递归就很耗性能
    //1  1  2  3  5  8  13  21 ...
    public int getFeeType(int n){
    	if (n <= 2) {
    		return 1;
    	}
    	return getFeeType(n - 1) + getFeeType(n -2);
        //这里在本方法中出现了本方法两次，要得出结果那么实际上该方法被调用的次数将会是2的n次方级别的，想一下要得到第100个数的值就得调用getFreeType方法2的100次方次
    }
    ```
    
    这种情况就思考如何用递推代替递归
    
    ```java
    //递推
    public int getFeeType(int n){
        int ia = 1;
        int ib = 1;
    	if (n <= 2) {
    		return 1;
    	}
        for (int i = 3 ; i <=n ; i++){
            ib += ia;//通过ib = ib + ia，ib成了第i个数的值
            ia = ib -ia;//ia的值成了第i-1个数的值
        }
    	return ib;
    }
    ```
    
    





## 五. 封装(重中之重)

### 1. 封装的概念

- 通常情况下可以在测试类给成员变量赋值一些合法但不合理的数值, 无论是编译阶段还是运行阶段都不会报错或者给出提示, 此时与现实生活不符
- 为了避免上述错误的发生, 就需要对成员变量进行密封包装处理, 来隐藏成员变量的细节以及保证成员变量数值的合理性,该机制就叫做封装

### 2. 封装的实现流程

- 私有化成员变量, 使用`private`关键字修饰
- 提供公有的get和set方法,并在set方法体中进行合理值的判断
- 在构造方法中调用set方法进行合理值的判断

## 六. JavaBean的概念(了解)

- JavaBean是一种遵循特定标准写出来的类
- JavaBean是一种Java语言写成的可重用组件,其他类可以通过反射机制发现和操作这些JavaBean的属性
- JavaBean本质上就是符合以下标准的类
  - 类是公共的(类名被`public`修饰)
  - 有一个无参的公共的构造器（这个构造器被`public`修饰）
  - 有属性, 且有对应的get、set方法



