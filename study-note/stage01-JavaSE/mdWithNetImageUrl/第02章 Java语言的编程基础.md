# 第02章 Java语言的编程基础

[toc]

## 第一节 变量(==重中之重==)

### 变量的基本概念
#### 变量的本质(变量本身)
变量就是一块在内存上圈出来的存储区间,这个存储区间内的电位的不同状态的不同组合方式使得这个存储区间可以表示不同的值,所以变量可以被赋予不同的值.
#### 变量的名字
变量存储的值是为了被使用,所有的变量在创建出来时就会生成一个地址(为什么要有地址?因为变量所占的区间,相对于整个内存的空间就如九牛一毛,而且在内存上会同时存在大量的变量,根据地址去找可以方便快速地找到),但是变量的地址可读性太差(也很难记),根本无法从地址里推断出这个变量是干什么用的,不利于程序员开发程序,所以要给变量起一个名字(让人看到这个名字就知道这个变量是用来做什么的,),这个名字与这个变量的地址是绑定的,知道了名字就知道了地址就能找到这个变量,然后调用这个变量的值.

#### 数据类型

由于变量存放的值的大小不一样(一个值只会占8bit的空间,但却给它分了32bit的空间,有点儿浪费),甚至同一个值还可以表述不同的意义(比如二进制01000001,可以表达数字65,也可使表达字符A),为了节省内存的存储空间和合理地使用内存空间,所以在Java语言中使用数据类型对变量加以描述

### 变量的声明方式

- 数据类型 变量名 = 初始值;
- 其中`=初始值`可以省略, 但`;`不可以省略
- 变量在被调用前必须赋予初始值,否则会编译错误

### 变量的注意事项

- Java是强类型语言,变量在声明时必须指明其数据类型
- 变量在使用前必须初始化(赋予初始值)
- 变量不能重复声明(不同的变量不能起同一个名字)

### 标识符的命名法则

- 由字母、数字、_和\$组成，其中数字不能开头
- 不能使用Java语言的关键字(==所谓关键字是Java语言用于表示特殊含义的单词==)
- 区分大小写，长度没有限制（但建议不要太长，太长了不好记,也容易出错）
- 尽量做到见名知意，支持中文但不推荐使用
- 标识符可以给`属性`、`变量`、`方法`、`类`、`包`起名字

#### Java项目命名规范

| 类型 | 命名规范                               | 例子            |
| ---- | -------------------------------------- | --------------- |
| 项目 | 全部小写, 多个单词用中划线`-`分隔      | common-zq-utils |
| 模块 | 全部小写, 多个单词用中划线`-`分隔      | common-zq-utils |
| 包   | 全部小写                               |                 |
| 类   | 首字母大写, 剩下的单词遵循驼峰命名法则 |                 |
| 变量 | 首字母小写, 剩下的单词遵循驼峰命名法则 |                 |
| 常量 | 全部大写, 多个单词间用`_`分隔          |                 |
| 方法 | 首字母小写, 剩下的单词遵循驼峰命名法则 |                 |



### 官方库的使用

- JDK中带有大量的API类,是由Java系统带来的工具库,这些工具数以万计
- 使用这些类可以大大简化编程,提高开发效率
- 具体的API类功能,可以参阅Java的参考手册

## 第二节 数据类型

### 数据类型的分类

> 在Java语言中数据类型主要分为两大类: 基本数据类型和引用数据类型

#### 1. 基本数据类型

- 整数  --->  `byte`、`short`、`int`、`long`	==[整数类型的变量赋值时的数字常量默认类型是int类型]==
- 小数  --->  `float`、`double`		             	==[浮点数类型的变量赋值时的数字常量默认类型是double类型]==
- 布尔  --->  `boolean`
- 单个字符  --->  `char`

==共8种,字母都是小写,且对应单词是`关键字`, 未赋予初始值前的所有电位的状态都是0 .

#### 2. 应用数据类型[知道就行,后面会学]

数组

类、接口、枚举、标注

### 进制

进制的本质是多少个1绑成一捆

#### 常用的进制

##### 1. 二进制（binary，简写为bin）

逢2进1, 在Java语言中数字要以0b开头才能说明这是一个二进制数字

##### 2. 八进制（octonary，简写为octal）

逢8进1, 在Java语言中数字要以0开头才能说明这是一个八进制数字

##### 3. 十进制（decimalism, 简写为dec）

逢10进1, 在Java语言中没有前缀的数字默认是十进制数字

##### 4. 十六进制（hexadecima, 简写为hex）

逢16进1, 在Java语言中数字要以0x开头才能说明这是一个十六进制数字

#### 进制间的转换

##### ①.正整数的十进制转二进制

###### 1.除2取余法

|      | 125  | 余数 |
| ---- | ---- | ---- |
| ÷2   | 62   | 1    |
| ÷2   | 31   | 0    |
| ÷2   | 15   | 1    |
| ÷2   | 7    | 1    |
| ÷2   | 3    | 1    |
| ÷2   | 1    | 1    |
| ÷2   | 0    | 1    |

将余数倒过来就是125的二进制数

| 0b   | 0    | 1    | 1    | 1    | 1    | 1    | 0    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |

###### 2. 拆分法发

小于127的整数建议用拆分法

将十进制数拆分为若干个二进制权重的和,有该权重的写1,否则写0

比如89,找到大于89的最小权重

| 2^7^(128) | 2^6^(64) | 2^5^(32) | 2^4^(16) | 2^3^(8) | 2^2^(4) | 2^1^(2) | 2^0^(1) |
| --------- | -------- | -------- | -------- | ------- | ------- | ------- | ------- |
|           | 89-64=25 |          | 25-16=9  | 9-8=1   |         |         |         |
| 0         | 1        | 0        | 1        | 1       | 0       | 0       | 1       |

89的二进制数是01011001

##### ②. 负整数的十进制转二进制

十进制的正负数可以用`+`、`-`号区分，二进制中没有`+`、`-`号的概念，但是也有类似的东西。二进制使用最高位表示符号位，==符号位会参与运算==，用1表示负数，用0表示正数，但是问题是哪个是最高位呢？整数有4种类型，`byte`、`short`、`int`、`long`,分别占用1，2，3，4个字节，即对应8，16，32，64位，每种类型的的符号位都是其最左边的一位。

==最高位是符号位这个规则只对整数类型的二进制起作用，其他的数据类型不遵循这个规则（比如char类型）==

要得到一个负数的二进制，就要记住原码、反码、补码

正数的原码、反码、补码就是其二进制数，是相同的

比如7的原码、反码、补码都是00000111

- 负数的原码是其绝对值的原码的符号位改为1形成的二进制数
- 负数的反码是负数的原码符号位不变,其它位取反
- 负数的补码是反码+1

==负数再计算机中的二进制数是这个负数的补码==

如算出-7的二进制数

-7的二进制数是其补码

| 原码 | 1    | 0    | 0    | 0    | 0    | 1    | 1    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 反码 | 1    | 1    | 1    | 1    | 1    | 0    | 0    | 0    |
| 补码 | 1    | 1    | 1    | 1    | 1    | 0    | 0    | 1    |

计算一个负数补码的十进制10101010

补码减1获得反码；反码除符号位取反获得原码，根据原码算出这个负数

| 补码 | 1    | 0    | 1    | 0    | 1    | 0    | 1    | 0    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 反码 | 1    | 0    | 1    | 0    | 1    | 0    | 0    | 1    |
| 原码 | 1    | 1    | 0    | 1    | 0    | 1    | 1    | 0    |

-(2^6^ + 2^4^ + 2^2^ + 2^1^ ) = -86

### 基本数据类型的取值范围

#### ==整数类型的范围(必须记住)==

记住并理解一个公式：2^n-1^ + 2^n-2^ + 2^n-3^ ··· + 2^2^  + 2^1^ + 2^0^ = 2^n^ - 1

一个n位的二进制数的十进制数是：2^n-1^ + 2^n-2^ + 2^n-3^ ··· + 2^2^  + 2^1^ + 2^0^ = 2^n^ -1

单个字节其实就是byte类型：

- byte类型整数的二进制范围是0000 0000 ~ 1111 1111;
- 0000 0000 ~ 1111 1111可以分为正数范围0000 0000 ~ 0111 1111和负数范围1000 0000 ~ 1111 1111
- 正数范围 0000 0000 ~ 0111 1111 , 计算可得 0 ~ 2^7^ -1, 即0 ~ 127
- byte类型负数的二进制范围是1000 0000 ~ 1111 1111 , 可以分为两部分1000 0000和1000 0001 ~ 1111 1111
- 10000000在由补码算反码时, 减1是没有结果的, 所以也就求不到原码, 这里规定10000000的值是 -128 ,即 -2^7^
- 1000 0001 ~ 1111 1111的值是 -127 ~ -1
- 合起来 -128    -127 ~ -1    0 ~ 127 ,所以byte类型的取值范围是 -128 ~ 127 , 即-2^7^ ~ 2^7^-1
- short类型的范围1000 0000 0000 0000 ~ 0111 1111 1111 1111, 规定1000 0000 0000 0000的值是 -2^15^
- 同理int类型的最小值是-2^31^ , long类型的最小值是-2^63^
- byte类型占了1个字节, 8个电位 , 其取值范围是 -2^7^ ~ 2^7^-1
- short类型占了2个字节,16个电位, 其取值范围是-2^15^ ~ 2^15^-1
- int类型占了占了4个字节,32个电位,其取值范围是-2^31^ ~ 2^31^ ~ 1
- long类型占了8个字节,64个电位,其取值范围是-2^63^ ~ 2^63^-1
- ==整数类型的取值范围有个规律,占了n个电位,则取值范围是 -2^n-1^ ~ 2^n-1^-1==

#### 浮点数类型的取值范围

float类型占了4个字节, 32个电位, 叫做单精度浮点数, 可以表示7位有效数字, 范围是 -3.403E38 ~ 3.403E38

double类型占了8个字节, 64个电位, 叫做双精度浮点数,可以表示15位有效数字, 范围是 -1.798E308 ~ 1.798E308

#### 布尔类型的取值范围

boolean类型就两个值, true 和 false , 用来描述一件事的真假 , 布尔类型在内存中占的空间大小没有明确的规定, 可以认为是占了一个字节

#### 字符类型的取值范围

- char类型占了2个字节, 16个电位, 用于描述单个字符
- char类型没有符号位, 取值范围就是0000 0000 0000 0000 ~ 0 1111 1111 1111 1111 , 即 0 ~ 2^17-1^ - 1 , 即 0 ~ 2^16^-1 , 即 0 ~ 65535

### 基本数据类型间的转换

基本数据类型间的转换可以分为自动类型转换和强制类型转换 ==(boolean类型不能进行基本数据类型间的转换)==

==小类型数据转换为大类型时不会改变大小==

#### 自动类型转换

- 自动类型转换就是当给一个变量赋值时,值的类型与变量的类型不同,那么值的类型就会自动转换为变量的类型来完成赋值
- 当把某个类型的数据赋值给比该类型的取值范围大的类型的变量时,这个数据就会进行自动类型转换==(小类型转大类型)==
- 自动类型转换不会改变数据的大小

![ ](https://gitee.com/zq007012/java-study-record/raw/master/study-note/stage01-JavaSE/%E7%AC%AC02%E7%AB%A0%20Java%E8%AF%AD%E8%A8%80%E7%9A%84%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80.assets/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png)

#### 强制类型转换

- 将数据的类型强制转换成另一种类型
- 主要是指大类型数据转小类型数据, 当然也可以小类型转大类型
- 大类型数据强转小类型数据的结果是 从大类型的最低位开始,截取小类型所占的位数形成的小类型的二进制数
  - ```java
  int a = 129;//0000 0000 0000 0000 0000 0000 1000 0001 
  byte b = (byte)a;
  System.out.println("a = " + a);
  System.out.println("b = " + b);//1000 0001
  /*
  a = 129
  b = -127
  //强制类型转换就是从大类型的最低位开始,截取小类型所占的位数形成的小类型的二进制数
  */
    ```


- 大类型数据强转小类型可能会改变数据的大小

  - ``` java
    System.out.println((int)((char)0b11111111111111111));
    System.out.println((short)(char)0b11111111111111111);
    /*
    65535
    -1	
    */
    ```

### 直接量(又名字面量)

- 直接量是指Java程序中通过源代码直接给出的值
- 比如int i = 5 , double d = 0.5 , boolean b = false, char c = 'a' , String s = "HelloWorld" ; 其中5 , 0.5 , false , 'a' , "HelloWorld"就是直接量
- 直接量包含所有基本类型的数值 、字符串、null .

#### 直接量的默认类型

##### 整数类型

- 整数类型的直接量默认的类型是int 

- 在给小类型【byte、short】的变量赋值时 , 会自动`强制转换`为小类型 , 如果直接量的大小超过了小类型的范围 ,则会报错

  - ```java
    byte b = 127;
    /*
    byte b = 128;
    错误: 不兼容的类型: 从int转换到byte可能会有损失
    */
    ```
  ```
  
  ```
  
-  如果直接量的大小超过了int类型的范围, 那么直接量后面必须加`l`或`L` （由于int类型的范围太长不好记，所以最好给long类型的变量赋值时直积粮后面都加上`l`或`L`）

  - ```java
    long l = 888;
    long a = 888L;
    /*long b = 2147483648;
    错误: 整数太大
    */
    long b = 2147483648L;
    ```

##### 浮点数类型

- 浮点数类型的直接量默认的类型是double
- 给float类型的变量赋值时，直接量后面必须加`f`或`F`

### ASCII编码表

编码表 -- 记录每个编号对应的字符的表

| '0'      | 48   |
| -------- | ---- |
| 'A'      | 65   |
| 'a'      | 97   |
| 空格     | 32   |
| 换行符\n | 10   |
| 空字符   | 0    |

